/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package net.qoopo.engine3d.engines.render.buffer;

import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferByte;
import java.awt.image.Raster;
import java.util.Arrays;
import net.qoopo.engine3d.componentes.geometria.primitivas.QPixel;
import net.qoopo.engine3d.core.textura.QTextura;
import net.qoopo.engine3d.core.math.QColor;
import net.qoopo.engine3d.core.math.QMath;

/**
 * Framebuffer
 *
 * @author alberto
 */
public class QFrameBuffer {

    // este buffer adicional tiene información de material, entidad (transformación y demas) por cada pixel
    // no tiene información de color
    protected QPixel[][] pixelBuffer = null;

    // estas tres variables son el buffer de color que se llena despues de procesar los pixeles
    protected BufferedImage rendered;
    protected Raster renderedRaster;
    protected byte[] colorDatos;//el buffer de color propiamente hablando
    //buffer de profundidad
    protected float[][] zBuffer;
    private float minimo = 0, maximo = 0;
    private int ancho, alto;
    //esta textura si es diferente de nulo, dibujamos sobre ella tambien
    private QTextura textura;

    public QFrameBuffer(int ancho, int alto, QTextura texturaSalida) {
        this.ancho = ancho;
        this.alto = alto;
        zBuffer = new float[alto][ancho];
        rendered = new BufferedImage(ancho, alto, BufferedImage.TYPE_3BYTE_BGR);

//        colorDatos = ((DataBufferByte) rendered.getData().getDataBuffer()).getData();
//        renderedRaster = Raster.createRaster(rendered.getSampleModel(), new DataBufferByte(colorDatos, colorDatos.length), null);
        this.renderedRaster = this.rendered.getRaster();
        this.colorDatos = ((DataBufferByte) this.renderedRaster.getDataBuffer()).getData();

        //inicializa el buffer de pixeles
        pixelBuffer = new QPixel[alto][ancho];
        for (QPixel[] row : pixelBuffer) {
            for (int i = 0; i < row.length; i++) {
                row[i] = new QPixel();
            }
        }
        this.textura = texturaSalida;
    }

    public byte getRenderedBytes(int pos) {
        return colorDatos[pos];
    }

    public void setRenderedBytes(int pos, byte valor) {
        colorDatos[pos] = valor;
    }

    /**
     * Actualiza el bufferedimage y carga a la textura de salida
     */
    public void actualizarTextura() {
//        rendered.setData(renderedRaster);//se supone q lo puedo obviar
        try {
            if (textura != null) {
                textura.cargarTextura(rendered);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public QPixel[][] getPixelBuffer() {
        return pixelBuffer;
    }

    public void setPixelBuffer(QPixel[][] pixelBuffer) {
        this.pixelBuffer = pixelBuffer;
    }

    public BufferedImage getRendered() {
        return rendered;
    }

    public void setRendered(BufferedImage rendered) {
        this.rendered = rendered;
    }

    public byte[] getColorDatos() {
        return colorDatos;
    }

    public void setColorDatos(byte[] colorDatos) {
        this.colorDatos = colorDatos;
    }

    public float[][] getzBuffer() {
        return zBuffer;
    }

    public void setzBuffer(float[][] zBuffer) {
        this.zBuffer = zBuffer;
    }

    /**
     * Limpia el buffer de profundidad
     */
    public void clearDepthBuffer() {
        for (float[] row : zBuffer) {
            Arrays.fill(row, Float.POSITIVE_INFINITY);
        }
    }

    /**
     * Limpia el buffer de pixeles
     */
    public void limpiar() {
        for (QPixel[] row : pixelBuffer) {
//            for (int i = 0, len = row.length; i < len; i++) {
//                row[i].dibujar = false;
//            }
            for (QPixel px : row) {
                px.dibujar = false;
            }
        }

//        for (int x = 0; x < ancho; x++) {
//            for (int y = 0; y < alto; y++) {
//                pixelBuffer[y][x].dibujar = false;
//            }
//        }
    }

    /**
     * Llena el buffer de color con el color indicado
     *
     * @param color
     */
    public void llenarColor(QColor color) {
        Arrays.fill(colorDatos, (byte) 0); // llena con color negro dura 1ms
        //aca abajo llena cada posicion con el color dado, es 6 veces mas lento
//        for (int x = 0; x < ancho; x++) {
//            for (int y = 0; y < alto; y++) {
//                setQColor(x, y, color);
//            }
//        }
    }

    /**
     * Retorna la información del pixel en la coordenada dada
     *
     * @param y
     * @param x
     * @return
     */
    public QPixel getPixel(int y, int x) {
        try {
            return pixelBuffer[y][x];
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Consigue el valor de profundidad del buffer z
     *
     * @param y
     * @param x
     * @return
     */
    public float getDepthBuffer(int y, int x) {
        if (y < zBuffer.length && x < zBuffer[0].length) {
            return zBuffer[y][x];
        } else {
            return Float.POSITIVE_INFINITY;
        }
    }

    /**
     * Setea un valor de profundiad en el ZBuffer
     *
     * @param y
     * @param x
     * @param valor
     */
    public void setDepthBuffer(int y, int x, float valor) {
        zBuffer[y][x] = valor;
    }

    /**
     * Setea un color en las coordenadas dadas
     *
     * @param x
     * @param y
     * @param r
     * @param g
     * @param b
     */
    public void setRGB(int x, int y, float r, float g, float b) {

        setRenderedBytes((y * ancho + x) * 3, (byte) (b * 255));
        setRenderedBytes((y * ancho + x) * 3 + 1, (byte) (g * 255));
        setRenderedBytes((y * ancho + x) * 3 + 2, (byte) (r * 255));
    }

    /**
     * Devuelve el color de las coordenadas dadas
     *
     * @param x
     * @param y
     * @return
     */
    public QColor getColor(int x, int y) {
        return new QColor(
                QMath.byteToFloat(getRenderedBytes((y * ancho + x) * 3 + 2)) / 255.0f,
                QMath.byteToFloat(getRenderedBytes((y * ancho + x) * 3 + 1)) / 255.0f,
                QMath.byteToFloat(getRenderedBytes((y * ancho + x) * 3)) / 255.0f);
    }

    /**
     * Setea un color en las coordenadas dadas
     *
     * @param x
     * @param y
     * @param color
     */
    public void setQColor(int x, int y, QColor color) {
        if (color != null) {
            setRGB(x, y, color.r, color.g, color.b);
        }
    }

    /**
     * Obtiene un color con coordenadas normalizadas (de 0 a 1)
     *
     * @param x
     * @param y
     * @return
     */
    public QColor getColorNormalizado(float x, float y) {
        return getColor((int) (x * ancho), (int) (y * alto));
    }

    /**
     * Setea un color en las coordenadas normalizadas dadas
     *
     * @param x
     * @param y
     * @param color
     */
    public void setQColorNormalizado(float x, float y, QColor color) {
        setQColor((int) (x * ancho), (int) (y * alto), color);
    }

    public int getAncho() {
        return ancho;
    }

    public void setAncho(int ancho) {
        this.ancho = ancho;
    }

    public int getAlto() {
        return alto;
    }

    public void setAlto(int alto) {
        this.alto = alto;
    }

    /**
     * Calcula los máximos y minimos del mapa de profundidad, esto debido a que
     * no están normalizados
     */
    public void calcularMaximosMinimos() {
        minimo = Float.POSITIVE_INFINITY;
        maximo = Float.NEGATIVE_INFINITY;

        for (int i = 0; i < zBuffer.length; i++) {
            for (int j = 0; j < zBuffer[0].length; j++) {
                if (zBuffer[i][j] > maximo && zBuffer[i][j] != Float.POSITIVE_INFINITY) {
                    maximo = zBuffer[i][j];
                }
                if (zBuffer[i][j] < minimo && zBuffer[i][j] != Float.NEGATIVE_INFINITY) {
                    minimo = zBuffer[i][j];
                }
            }
        }
    }

    /**
     * Pinta el mapa de profundidad en el buffer de color
     */
    public void pintarMapaProfundidad() {
        try {
            Graphics gr = rendered.getGraphics();
            int rgb;
            int r = 0, g = 0, b = 0;

//        float minimo = zBuffer[0][0];
            calcularMaximosMinimos();

            for (int y = 0; y < zBuffer.length; y++) {
                for (int x = 0; x < zBuffer[0].length; x++) {
                    b = g = r = (int) ((zBuffer[y][x] - minimo) * 255 / maximo);
                    rgb = r;
                    rgb = (rgb << 8) + g;
                    rgb = (rgb << 8) + b;
                    rendered.setRGB(x, y, rgb);
                }
            }
            gr.drawImage(rendered, 0, 0, rendered.getWidth(), rendered.getHeight(), null);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public QTextura getTextura() {
        return textura;
    }

    public void setTextura(QTextura textura) {
        this.textura = textura;
    }

    public float getMinimo() {
        return minimo;
    }

    public void setMinimo(float minimo) {
        this.minimo = minimo;
    }

    public float getMaximo() {
        return maximo;
    }

    public void setMaximo(float maximo) {
        this.maximo = maximo;
    }

    /**
     * Realiza una copia de un buffer a otro con dimensiones diferentes
     *
     * @param buffer
     * @param ancho
     * @param alto
     * @return
     */
    public static QFrameBuffer copiar(QFrameBuffer buffer, int ancho, int alto) {
//        QFrameBuffer nuevo = new QFrameBuffer(ancho, alto, buffer.getTextura());
        QFrameBuffer nuevo = new QFrameBuffer(ancho, alto, null);
        QColor color;
        try {
            //si es expandir
            if (buffer.getAncho() < ancho) {
                for (int x = 0; x < nuevo.getAncho(); x++) {
                    for (int y = 0; y < nuevo.getAlto(); y++) {
                        color = buffer.getColorNormalizado((float) x / nuevo.getAncho(), (float) y / nuevo.getAlto());
                        nuevo.setQColor(x, y, color);
                    }
                }
            } else {
                //si es encojer
                for (int x = 0; x < buffer.getAncho(); x++) {
                    for (int y = 0; y < buffer.getAlto(); y++) {
                        color = buffer.getColor(x, y);
                        nuevo.setQColorNormalizado((float) x / buffer.getAncho(), (float) y / buffer.getAlto(), color);
                    }
                }
            }

        } catch (Exception e) {

        }

        return nuevo;
    }
}
